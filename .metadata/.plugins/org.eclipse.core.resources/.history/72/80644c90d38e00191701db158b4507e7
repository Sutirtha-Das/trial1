/**
 * 
 */
package com.rabobank.com.rabobank.service.impl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;

import com.rabobank.com.rabobank.model.InvalidRecords;
import com.rabobank.com.rabobank.model.Records;
import com.rabobank.com.rabobank.model.Records.Record;
import com.rabobank.com.rabobank.service.RaboBankValidationService;


/**
 * @author Sutirtha
 *
 */
@Service
public class RaboBankValidationServiceImpl implements RaboBankValidationService {

	/* (non-Javadoc)
	 * @see com.rabobank.com.rabobank.service.RaboBankValidationService#validateTransactionRecords(com.rabobank.com.rabobank.model.Records)
	 */
	@Override
	public List<InvalidRecords> validateTransactionRecords(Records records) {
		List<InvalidRecords> invalidRecords = invalidTransactionMutations(records.getRecord());
		invalidRecords.addAll(RaboBankValidationServiceImpl.getDuplicates(records.getRecord()));
		return invalidRecords;
		
	}
	
	public static List<InvalidRecords> getDuplicates(final List<Records.Record> recordList) {
		List<InvalidRecords> records = new ArrayList<InvalidRecords>();
		Map<Integer, List<Records.Record>> duplicates = getDuplicatesMap(recordList);
		duplicates.values().stream().filter(r -> r.size()>1).forEach(rec ->{
				rec.stream().forEach(r ->{
					InvalidRecords invalidr = new InvalidRecords(r.getReference(),r.getDescription());
					System.out.println(r.getDescription());
					System.out.println(r.getReference());
					records.add(invalidr);
				});
		});
		
		return records;
	}
	private static Map<Integer, List<Records.Record>> getDuplicatesMap(List<Records.Record> recordList) {

		return recordList.stream().collect(Collectors.groupingBy(Records.Record::getReference));
	}	
	private List<InvalidRecords> invalidTransactionMutations(List<Records.Record> recordList){
		List<InvalidRecords> invalidRecordsResult = new ArrayList<InvalidRecords>();
		List<Records.Record> invalidRecords = validateMutation(recordList);
		invalidRecords.stream().forEach(iR ->{
			InvalidRecords invalidr = new InvalidRecords(iR.getReference(),iR.getDescription());
			System.out.println(iR.getDescription());
			System.out.println(iR.getReference());
			invalidRecordsResult.add(invalidr);
		});
		
		return invalidRecordsResult;
	}
	private List<Records.Record> validateMutation(List<Records.Record> recordList) {
		 return recordList.stream().filter(transaction -> !isValid(transaction)).collect(Collectors.toList());
	 }

	 private boolean isValid(Records.Record record) {
		 return Math.round(record.getEndBalance() - record.getStartBalance()) == Math.round(record.getMutation());
	 }
}
