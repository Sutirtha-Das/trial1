/**
 * 
 */
package com.rabobank.com.rabobank.service.impl;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;

import com.SapFeeCalcSutirtha.SapFeeCalcSutirtha.model.TransactionReport;
import com.rabobank.com.rabobank.model.InvalidRecords;
import com.rabobank.com.rabobank.model.Records;
import com.rabobank.com.rabobank.model.Records.Record;
import com.rabobank.com.rabobank.service.RaboBankValidationService;


/**
 * @author Sutirtha
 *
 */
@Service
public class RaboBankValidationServiceImpl implements RaboBankValidationService {

	/* (non-Javadoc)
	 * @see com.rabobank.com.rabobank.service.RaboBankValidationService#validateTransactionRecords(com.rabobank.com.rabobank.model.Records)
	 */
	@Override
	public List<InvalidRecords> validateTransactionRecords(Records records) {
		List<InvalidRecords> invalidRecords = invalidTransactionMutations(records.getRecord());
		invalidRecords.addAll(RaboBankValidationServiceImpl.getDuplicates(records.getRecord()));
		return invalidRecords;
		
	}
	
	public static List<InvalidRecords> getDuplicates(final List<Records.Record> recordList) {
		List<InvalidRecords> records = new ArrayList<InvalidRecords>();
		Map<Integer, List<Records.Record>> duplicates = getDuplicatesMap(recordList);
		duplicates.values().stream().filter(r -> r.size()>1).forEach(rec ->{
				rec.stream().forEach(r ->{
					InvalidRecords invalidr = new InvalidRecords(r.getReference(),r.getDescription());
					System.out.println(r.getDescription());
					System.out.println(r.getReference());
					records.add(invalidr);
				});
		});
		
		return records;
	}
	private static Map<Integer, List<Records.Record>> getDuplicatesMap(List<Records.Record> recordList) {

		return recordList.stream().collect(Collectors.groupingBy(Records.Record::getReference));
	}	
	private List<InvalidRecords> invalidTransactionMutations(List<Records.Record> recordList){
		List<InvalidRecords> invalidRecordsResult = new ArrayList<InvalidRecords>();
		List<Records.Record> invalidRecords = validateMutation(recordList);
		invalidRecords.stream().forEach(iR ->{
			InvalidRecords invalidr = new InvalidRecords(iR.getReference(),iR.getDescription());
			System.out.println(iR.getDescription());
			System.out.println(iR.getReference());
			invalidRecordsResult.add(invalidr);
		});
		
		return invalidRecordsResult;
	}
	private List<Records.Record> validateMutation(List<Records.Record> recordList) {
		 return recordList.stream().filter(transaction -> !isValid(transaction)).collect(Collectors.toList());
	 }

	 private boolean isValid(Records.Record record) {
		 return Math.round(record.getEndBalance() - record.getStartBalance()) == Math.round(record.getMutation());
	 }
	 
	 private void writeTransactionReport(List<InvalidRecords> invalidTransactionList) throws IOException{
			File file = new File(config.getOutputFilePath());
			if(!file.exists()){
				file.createNewFile();
			}
			
			FileWriter fw = new FileWriter(file);
			BufferedWriter bw = new BufferedWriter(fw);
			bw.write("Transaction Reference");
			bw.write(",");
			bw.write("Description");
			bw.write(",");
			bw.newLine();
			
			invalidTransactionList.stream().forEach(t ->{
				try {
					bw.write(t.getTransactionReference());
					bw.write(",");
					bw.write(t.getDescription());
					bw.write(",");
					bw.write(t.getTransactionDate());
					bw.write(",");
					bw.write(t.getPriorityFlag());
					bw.write(",");
					bw.write("$"+ String.valueOf(t.getProcessingFee()));
					bw.write(",");
					bw.newLine();
				} catch (Exception e) {
					e.printStackTrace();
				}
			});
			
			bw.flush();
			bw.close();
			fw.close();
		}
}
